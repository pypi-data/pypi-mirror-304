# generated by datamodel-codegen:
#   filename:  input.json
#   timestamp: 2024-10-25T08:14:19+00:00

from __future__ import annotations

from typing import Any, List, Optional, Union

from pydantic import BaseModel, Field


class Inputs(BaseModel):
    image: Any = Field(..., description="The image on which the question is asked")
    question: str = Field(..., description="A question to ask of the document")


class DocumentQuestionAnsweringParameters(BaseModel):
    doc_stride: Optional[int] = Field(
        None,
        description="If the words in the document are too long to fit with the question for the model, it will be split in several chunks with some overlap. This argument controls the size of that overlap.",
    )
    handle_impossible_answer: Optional[bool] = Field(None, description="Whether to accept impossible as an answer")
    lang: Optional[str] = Field(None, description="Language to use while running OCR. Defaults to english.")
    max_answer_len: Optional[int] = Field(
        None,
        description="The maximum length of predicted answers (e.g., only answers with a shorter length are considered).",
    )
    max_seq_len: Optional[int] = Field(
        None,
        description="The maximum length of the total sentence (context + question) in tokens of each chunk passed to the model. The context will be split in several chunks (using doc_stride as overlap) if needed.",
    )
    max_question_len: Optional[int] = Field(
        None,
        description="The maximum length of the question after tokenization. It will be truncated if needed.",
    )
    top_k: Optional[int] = Field(
        None,
        description="The number of answers to return (will be chosen by order of likelihood). Can return less than top_k answers if there are not enough options available within the context.",
    )
    word_boxes: Optional[List[Union[str, List[float]]]] = Field(
        None,
        description="A list of words and bounding boxes (normalized 0->1000). If provided, the inference will skip the OCR step and use the provided bounding boxes instead.",
    )


class DocumentQuestionAnsweringInput(BaseModel):
    inputs: Inputs = Field(
        ...,
        description="One (document, question) pair to answer",
        title="DocumentQuestionAnsweringInputData",
    )
    parameters: Optional[DocumentQuestionAnsweringParameters] = Field(
        None, description="Additional inference parameters"
    )
