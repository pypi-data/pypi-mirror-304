# coding: utf-8

"""
    Peblar local REST API

    # General This document contains the specification of the WLAC local REST API. This API for local networks is supported by Peblar products from firmware versions 1.6 and onwards. Before the API can be accessed, it is required to be enabled in the advanced settings page of the chargers web interface. The endpoints described below can be reached via http://\\<local_ip\\>/api/wlac/v1/\\<endpoint_name\\> for example http://10.11.12.13/api/wlac/v1/evinterface. <br><br> <img src=\"./images/api_enable.png\"/> <br> 

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class EVInterfaceResponse(BaseModel):
    """
    EVInterfaceResponse
    """ # noqa: E501
    cp_state: Optional[StrictStr] = Field(default=None, description="The current state of the Control Pilot which can be:   - State A: No EV connected   - State B: EV connected but suspended by either EV or charger   - State C: EV connected and charging   - State D: Same as C but ventilation requested (not supported)   - State E: Error, short to PE or powered off   - State F: Fault detected by charger   - Invalid: Invalid CP level measured   - Unknown: CP signal cannot be measured.  See [Electric vehicle conductive charging systems - part 1: general requirements, IEC 61851-1, Edition 3.0, 2017-2] for more details on these states. ", alias="CpState")
    lock_state: Optional[StrictBool] = Field(default=None, description="The current state of the socket lock (false = unlocked, true = locked). This value is not present on fixed cable systems.", alias="LockState")
    charge_current_limit: Optional[StrictInt] = Field(default=None, description="The maximum current indicated towards the EV in milliAmpere by this API. Note that other factors can cause an even lower limit (e.g. thermal); These are communicated via the fields ChargeCurrentLimitSource and ChargeCurrentLimitActual. ", alias="ChargeCurrentLimit")
    charge_current_limit_source: Optional[StrictStr] = Field(default=None, description="One of the following sources will be actively limiting the charging current:    - Charging cable: The maximum rated current of the attached cable.   - High temperature: Charger internal temperature.   - Installation limit: The maximum installation current configured during commissioning.   - Dynamic load balancing: Household installation phase current reached maximum.   - Group load balancing: A maximum communicated by the leader of the group.   - Overcurrent protection: EV exceeded communicated maximum current.   - Hardware limitation: Physical limits of the charger.   - Power factor: EV charged with too low power factor.   - OCPP smart charging: Smart charging profile installed by CPO.   - Phase imbalance: Too much imbalance between phases.   - Local scheduled charging: Locally configured scheduled charging.   - Solar charging: Amount of exported energy.   - Current limiter: User selected limit via web web-interface.   - Local REST API: Limit set by this API.   - Local Modbus API: Limit set by the Modbus API.   - External power limit: External IO defined limit.   - Household power limit: Total household power capacity limit. ", alias="ChargeCurrentLimitSource")
    charge_current_limit_actual: Optional[StrictInt] = Field(default=None, description="The actual current which is communicated to the vehicle per phase. This is the lowest current of all limiting sources.", alias="ChargeCurrentLimitActual")
    force1_phase: Optional[StrictBool] = Field(default=None, description="Use only 1 phase for charging (if supported by the charger, see \"Force1PhaseAllowed\"). If a charging session is already ongoing, a switch-over from 3 to 1 phase is done automatically by the charger.", alias="Force1Phase")
    __properties: ClassVar[List[str]] = ["CpState", "LockState", "ChargeCurrentLimit", "ChargeCurrentLimitSource", "ChargeCurrentLimitActual", "Force1Phase"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EVInterfaceResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EVInterfaceResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "CpState": obj.get("CpState"),
            "LockState": obj.get("LockState"),
            "ChargeCurrentLimit": obj.get("ChargeCurrentLimit"),
            "ChargeCurrentLimitSource": obj.get("ChargeCurrentLimitSource"),
            "ChargeCurrentLimitActual": obj.get("ChargeCurrentLimitActual"),
            "Force1Phase": obj.get("Force1Phase")
        })
        return _obj


