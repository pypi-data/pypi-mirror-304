# This file was auto-generated by Fern from our API Definition.

from ..core.pydantic_utilities import UniversalBaseModel
import typing_extensions
import typing
from ..core.serialization import FieldMetadata
import pydantic
from .transcription_endpointing_plan import TranscriptionEndpointingPlan
from ..core.pydantic_utilities import IS_PYDANTIC_V2


class StartSpeakingPlan(UniversalBaseModel):
    wait_seconds: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="waitSeconds")] = (
        pydantic.Field(default=None)
    )
    """
    This is how long assistant waits before speaking. Defaults to 0.4.
    
    This is the minimum it will wait but if there is latency is the pipeline, this minimum will be exceeded. This is really a stopgap in case the pipeline is moving too fast.
    
    Example:
    
    - If model generates tokens and voice generates bytes within 100ms, the pipeline still waits 300ms before outputting speech.
    
    Usage:
    
    - If the customer is taking long pauses, set this to a higher value.
    - If the assistant is accidentally jumping in too much, set this to a higher value.
    
    @default 0.4
    """

    smart_endpointing_enabled: typing_extensions.Annotated[
        typing.Optional[bool], FieldMetadata(alias="smartEndpointingEnabled")
    ] = pydantic.Field(default=None)
    """
    This determines if a customer speech is considered done (endpointing) using the VAP model on customer's speech. This is good for middle-of-thought detection.
    
    Once an endpoint is triggered, the request is sent to `assistant.model`.
    
    Default `false` since experimental.
    
    @default false
    """

    transcription_endpointing_plan: typing_extensions.Annotated[
        typing.Optional[TranscriptionEndpointingPlan], FieldMetadata(alias="transcriptionEndpointingPlan")
    ] = pydantic.Field(default=None)
    """
    This determines how a customer speech is considered done (endpointing) using the transcription of customer's speech.
    
    Once an endpoint is triggered, the request is sent to `assistant.model`.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
