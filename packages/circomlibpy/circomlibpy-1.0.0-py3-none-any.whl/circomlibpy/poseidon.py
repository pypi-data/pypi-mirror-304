from circomlibpy.poseidon_constants import opt_c
from circomlibpy.poseidon_constants import opt_s
from circomlibpy.poseidon_constants import opt_m
from circomlibpy.poseidon_constants import opt_p

MODUL = 21888242871839275222246405745257275088548364400416034343698204186575808495617
N_ROUNDS_F = 8
N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68]


class Helper:

    @classmethod
    def sigma(cls, x: int) -> int:
        # (x ^ 5) mod MODUL
        return pow(x, 5, MODUL)

    @classmethod
    def ark(cls, t: int, C: list[int], r: int, x: list[int]) -> list[int]:
        return [(x[i] + C[i + r]) % MODUL for i in range(t)]

    @classmethod
    def mix(cls, t: int, M: list[list[int]], x: list[int]) -> list[int]:
        """ Maximum Distance Separable transformation"""
        return [cls.mix_last(t, M, i, x) for i in range(t)]

    @classmethod
    def mix_last(cls, t: int, M: list[list[int]], s: int, x: list[int]) -> int:
        return sum(M[j][s] * x[j] for j in range(t)) % MODUL

    @classmethod
    def mix_s(cls, t: int, S: list[int], r: int, x: list[int]):
        out: list[int] = []

        _tr = (t * 2 - 1) * r

        # first element
        out.append(sum(S[_tr + i] * x[i] for i in range(t)) % MODUL)

        # other elements
        for i in range(1, t):
            out.append((S[_tr + i + t - 1] * x[0] + x[i]) % MODUL)

        return out


class PoseidonHash:
    # https://github.com/iden3/circomlibjs/blob/main/src/poseidon_opt.js

    def hash(self, n_inputs: int, inputs: list[int]):
        build = self._build_poseidon(n_inputs, 1, inputs, 0)
        return build[0]

    def _build_poseidon(
            self,
            n_inputs: int,
            n_outs: int,
            inputs: list[int],
            initial_state: int
    ) -> list[int]:
        # Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
        # Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
        # And rounded up to nearest integer that divides by t

        # Initialization of Poseidon parameters from specifications
        t = n_inputs + 1  # Полный размер состояния (включая initial_state)
        n_rounds_f = N_ROUNDS_F
        # TODO: t-2 > len(N_ROUNDS_P)
        n_rounds_p = N_ROUNDS_P[t - 2]

        # Generation of constant parameters
        C = opt_c(t)
        S = opt_s(t)
        M = opt_m(t)
        P = opt_p(t)

        # Auxiliary arrays for storing intermediate results
        sigma_f: list[list[int]] = [[0] * t for _ in range(n_rounds_f)]
        ark: list[list[int] | int] = [0] * n_rounds_f
        mix: list[list[int] | int] = [[0] * t] * (n_rounds_f - 1)
        mix_s: list[list[int] | int] = [[0] * t] * n_rounds_p

        # Initialization of the state with the addition of the initial state
        # TODO: j < 0?
        state = [inputs[j - 1] if j > 0 else initial_state for j in range(t)]
        ark[0] = Helper.ark(t, C, 0, state)

        # Full rounds: first full rounds
        sigma_f, ark, mix = self._full_rounds_first_half(t, C, M, n_rounds_f // 2 - 1, 0, sigma_f, mix, ark)

        # Half full round (mid-round)
        sigma_f, ark, mix = self._mid_round_processing(t, C, P, n_rounds_f // 2, sigma_f, mix, ark)

        # Partial rounds
        sigma_p, mix_s = self._partial_round_processing(t, C, S, n_rounds_f // 2, n_rounds_p, mix, mix_s)

        # Second full rounds
        sigma_f, ark, mix = self._full_rounds_second_half(
            t, C, M, n_rounds_f // 2 - 1, n_rounds_f // 2, n_rounds_p, sigma_f, mix, mix_s, ark)

        # Final round and output values
        sigma_f, mix_last = self._final_round_processing(t, M, n_rounds_f, n_outs, sigma_f, mix)

        return mix_last

    @staticmethod
    def _full_rounds_first_half(
            t: int,
            C: list[int],
            M: list[list[int]],
            n_rounds: int,
            start_index: int,
            sigma_f: list[list[int]],
            mix: list[list[int]],
            ark: list[list[int]],
    ):
        for r in range(n_rounds):
            for j in range(t):
                # Definition of the input value for sigma
                input_value = ark[0][j] if r == 0 else mix[start_index + r - 1][j]
                sigma_f[start_index + r][j] = Helper.sigma(input_value)

            # Updating the ark state
            state = [sigma_f[start_index + r][j] for j in range(t)]
            ark[start_index + r + 1] = Helper.ark(t, C, (start_index + r + 1) * t, state)

            # Updating the mix values
            mix[start_index + r] = Helper.mix(t, M, ark[start_index + r + 1])

        return sigma_f, ark, mix

    @staticmethod
    def _full_rounds_second_half(
            t: int,
            C: list[int],
            M: list[list[int]],
            n_rounds: int,
            start_index: int,
            n_rounds_p: int,
            sigma_f: list[list[int]],
            mix: list[list[int]],
            mix_s: list[list[int]],
            ark: list[list[int]],
    ):
        for r in range(n_rounds):
            for j in range(t):
                # Definition of the input value for sigma
                input_value = mix_s[n_rounds_p - 1][j] if r == 0 else mix[start_index + r - 1][j]
                sigma_f[start_index + r][j] = Helper.sigma(input_value)

            # Updating the ark state
            state = [sigma_f[start_index + r][j] for j in range(t)]
            ark[start_index + r + 1] = Helper.ark(t, C, (start_index + r + 1) * t + n_rounds_p, state)

            # Updating the mix values
            mix[start_index + r] = Helper.mix(t, M, ark[start_index + r + 1])

        return sigma_f, ark, mix

    @staticmethod
    def _mid_round_processing(
            t: int,
            C: list[int],
            P: list[list[int]],
            n_rounds: int,
            sigma_f: list[list[int]],
            mix: list[list[int]],
            ark: list[list[int]],
    ):
        mid_index = n_rounds - 1
        for j in range(t):
            sigma_f[mid_index][j] = Helper.sigma(mix[mid_index - 1][j])

        state = [sigma_f[mid_index][j] for j in range(t)]
        ark[n_rounds] = Helper.ark(t, C, n_rounds * t, state)
        mix[mid_index] = Helper.mix(t, P, ark[n_rounds])

        return sigma_f, ark, mix

    @staticmethod
    def _partial_round_processing(
            t: int,
            C: list[int],
            S: list[int],
            n_rounds: int,
            n_rounds_p: int,
            mix: list[list[int]],
            mix_s: list[list[int]],
    ):
        sigma_p: list[int] = [0] * n_rounds_p

        for r in range(n_rounds_p):
            sigma_p[r] = Helper.sigma(mix[n_rounds - 1][0] if r == 0 else mix_s[r - 1][0])

            state = [
                (sigma_p[r] + C[(n_rounds + 1) * t + r]) % MODUL if j == 0 else
                (mix[n_rounds - 1][j] if r == 0 else mix_s[r - 1][j])
                for j in range(t)
            ]

            mix_s[r] = Helper.mix_s(t, S, r, state)

        return sigma_p, mix_s

    @staticmethod
    def _final_round_processing(
            t: int,
            M: list[list[int]],
            n_rounds_f: int,
            n_outs: int,
            sigma_f: list[list[int]],
            mix: list[list[int]],
    ):
        # Final round
        for j in range(t):
            sigma_f[n_rounds_f - 1][j] = Helper.sigma(mix[n_rounds_f - 2][j])

        # Output value through MixLast
        mix_last: list[int] = []
        for i in range(n_outs):
            state = [sigma_f[n_rounds_f - 1][j] for j in range(t)]
            mix_last.append(Helper.mix_last(t, M, i, state))

        return sigma_f, mix_last
