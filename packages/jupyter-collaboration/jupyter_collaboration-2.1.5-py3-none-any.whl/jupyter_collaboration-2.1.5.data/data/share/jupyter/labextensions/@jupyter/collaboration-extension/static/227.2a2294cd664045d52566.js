"use strict";(self.webpackChunk_jupyter_collaboration_extension=self.webpackChunk_jupyter_collaboration_extension||[]).push([[227,719],{1227:(e,s,t)=>{t.r(s),t.d(s,{ICollaborativeDrive:()=>f,WebSocketAwarenessProvider:()=>c,WebSocketProvider:()=>p,YDrive:()=>y});var o,r=t(4901),n=t(2256),i=t(9476),a=t(7099);!function(e){e[e.CHAT=125]="CHAT"}(o||(o={}));class c extends a.WebsocketProvider{constructor(e){super(e.url,e.roomID,e.awareness.doc,{awareness:e.awareness}),this._isDisposed=!1,this._awareness=e.awareness,this._user=e.user,this._user.ready.then((()=>this._onUserChanged(this._user))).catch((e=>console.error(e))),this._user.userChanged.connect(this._onUserChanged,this),this._messageStream=new r.Stream(this),this.messageHandlers[o.CHAT]=(e,s,t,o,r)=>{const i=n.kf(s),a=JSON.parse(i);this._messageStream.emit(a)}}get isDisposed(){return this._isDisposed}get messageStream(){return this._messageStream}dispose(){this._isDisposed||(this._user.userChanged.disconnect(this._onUserChanged,this),this._isDisposed=!0,this.destroy())}sendMessage(e){const s={type:"text",body:e},t=i.Mf();i.uE(t,o.CHAT),i.uw(t,JSON.stringify(s)),this.ws.send(i._f(t))}_onUserChanged(e){this._awareness.setLocalStateField("user",e.identity)}}var h=t(8492),d=t(1182),l=t(4083),_=t(7930);class p{constructor(e){this._onConnectionClosed=e=>{1003===e.code&&(console.error("Document provider closed:",e.reason),(0,l.showErrorMessage)(this._trans.__("Document session error"),e.reason,[l.Dialog.okButton()]),this._sharedModel.dispose())},this._onSync=e=>{var s;e&&(this._ready.resolve(),null===(s=this._yWebsocketProvider)||void 0===s||s.off("sync",this._onSync))},this._ready=new _.PromiseDelegate,this._isDisposed=!1,this._path=e.path,this._contentType=e.contentType,this._format=e.format,this._serverUrl=e.url,this._sharedModel=e.model,this._awareness=e.model.awareness,this._yWebsocketProvider=null,this._trans=e.translator;const s=e.user;s.ready.then((()=>{this._onUserChanged(s)})).catch((e=>console.error(e))),s.userChanged.connect(this._onUserChanged,this),this._connect().catch((e=>console.warn(e)))}get isDisposed(){return this._isDisposed}get ready(){return this._ready.promise}dispose(){var e,s,t;this.isDisposed||(this._isDisposed=!0,null===(e=this._yWebsocketProvider)||void 0===e||e.off("connection-close",this._onConnectionClosed),null===(s=this._yWebsocketProvider)||void 0===s||s.off("sync",this._onSync),null===(t=this._yWebsocketProvider)||void 0===t||t.destroy(),r.Signal.clearData(this))}async _connect(){const e=await async function(e,s,t){const o=d.ServerConnection.makeSettings(),r=h.URLExt.join(o.baseUrl,"api/collaboration/session",encodeURIComponent(t)),n={method:"PUT",body:JSON.stringify({format:e,type:s})};let i;try{i=await d.ServerConnection.makeRequest(r,n,o)}catch(e){throw new d.ServerConnection.NetworkError(e)}let a=await i.text();if(a.length>0)try{a=JSON.parse(a)}catch(e){console.log("Not a JSON response body.",i)}if(!i.ok)throw new d.ServerConnection.ResponseError(i,a.message||a);return a}(this._format,this._contentType,this._path);this._yWebsocketProvider=new a.WebsocketProvider(this._serverUrl,`${e.format}:${e.type}:${e.fileId}`,this._sharedModel.ydoc,{disableBc:!0,params:{sessionId:e.sessionId},awareness:this._awareness}),this._yWebsocketProvider.on("sync",this._onSync),this._yWebsocketProvider.on("connection-close",this._onConnectionClosed)}_onUserChanged(e){this._awareness.setLocalStateField("user",e.identity)}}const u="true"===h.PageConfig.getOption("disableRTC");class y extends d.Drive{constructor(e,s){super({name:"RTC"}),this._onCreate=(e,s)=>{if("string"==typeof e.format)try{const t=new p({url:h.URLExt.join(this.serverSettings.wsUrl,"api/collaboration/room"),path:e.path,format:e.format,contentType:e.contentType,model:s,user:this._user,translator:this._trans}),o=`${e.format}:${e.contentType}:${e.path}`;this._providers.set(o,t),s.disposed.connect((()=>{const e=this._providers.get(o);e&&(e.dispose(),this._providers.delete(o))}))}catch(s){console.error(`Failed to open websocket connection for ${e.path}.\n:${s}`)}},this._user=e,this._trans=s,this._providers=new Map,this.sharedModelFactory=new m(this._onCreate)}dispose(){this.isDisposed||(this._providers.forEach((e=>e.dispose())),this._providers.clear(),super.dispose())}async get(e,s){if(s&&s.format&&s.type){const t=`${s.format}:${s.type}:${e}`,o=this._providers.get(t);if(o){const[t]=await Promise.all([super.get(e,{...s,content:!1}),o.ready]);return{...t,format:s.format}}}return super.get(e,s)}async save(e,s={}){if(s.format&&s.type){const t=`${s.format}:${s.type}:${e}`;if(this._providers.get(t)){const t={type:s.type,format:s.format,content:!1};return this.get(e,t)}}return super.save(e,s)}}class m{constructor(e){this._onCreate=e,this.collaborative=!u,this._documentFactories=new Map}registerDocumentFactory(e,s){if(this._documentFactories.has(e))throw new Error(`The content type ${e} already exists`);this._documentFactories.set(e,s)}createNew(e){if("string"==typeof e.format){if(this.collaborative&&e.collaborative&&this._documentFactories.has(e.contentType)){const s=this._documentFactories.get(e.contentType)(e);return this._onCreate(e,s),s}}else console.warn(`Only defined format are supported; got ${e.format}.`)}}const f=new _.Token("@jupyter/collaboration-extension:ICollaborativeDrive")}}]);