import copy
import functools
import inspect
import os
import sys
import warnings
from collections import defaultdict
from dataclasses import _PARAMS, Field, asdict, dataclass, is_dataclass
from typing import Any, Callable, ClassVar, Iterable, Protocol, Self, overload

from ..utils import is_dynamically_created, slots_to_dict
from .config import Config, is_config
from .params import ConfigParams

_CONFIG_PARAMS = "__config_params__"  # attribute for ConfigParams tuple
_ASSIGN_PARAMS = "__assign_params__"  # method for setting config params


def is_configurable(obj: Any) -> bool:
    """Check if the object is a configurable.

    Returns :data:`True` if the object is a configurable or an instance
    of a configurable.

    Args:
        obj (typing.Any): The object to check.

    Returns:
        bool: Whether the object is a configurable.
    """
    cls = obj if isinstance(obj, type) else type(obj)
    return hasattr(cls, _CONFIG_PARAMS)


class configurable[T, C]:
    """

    Warning:
        Very rare case: if you create your configurable class
        dynamically (if you don't know what it means then ignore this
        warning) and it is a dataclass and you use a custom method that
        can be otherwise auto-generated by the @dataclass decorator,
        such as __init__, __repr__, __eq__ etc., first "decorate" the
        class with @configurable and only then with @dataclass, e.g.,
        ``obj = dataclass(configurable(make_my_configurable()))``

        This is because it is otherwise impossible to distinguish
        whether any such method was user-defined or auto-generated.
        Auto-generated methods are regenerated to exclude any
        intersection with config parameters, in case the decorated
        configurable has configs defined as bases/"parents". Even if
        the configs are defined in another way (e.g., via ``config``
        argument or as inner classes), the methods are still regenerated
        to keep this code simple.
    """

    # Do not remove the metaclass if it exists, keep it instead of default, e.g., maybe the user wants to assign params after init
    CONFIG_TO_CONFIGURABLE: ClassVar[
        dict[tuple[type[Config], ...], list[type["Configurable"]]]
    ] = defaultdict(list)

    CONFIGURABLE_TO_CONFIG: ClassVar[
        dict[type["Configurable"], tuple[ConfigParams, ...]]
    ] = {}

    def __init__(
        self,
        cls: type[T] | None = None,
        /,
        *,
        config: C | tuple[C, ...] | None = None,
        is_config: Callable[[type[Any]], bool] = is_config,
        propagate_kwargs: bool = False,
        doc_desc_newline: str = "\n" + " " * 8,
        doc_type_max_depth: int = 1,
        doc_get_desc_fn: Callable[[Iterable[Field[Any]], str], str] | None = None,
    ) -> None:
        # Store the arguments
        self.cls = cls
        self.config = config
        self.is_config = is_config
        self.propagate_kwargs = propagate_kwargs
        self.doc_desc_newline = doc_desc_newline
        self.doc_type_max_depth = doc_type_max_depth
        self.doc_get_desc_fn = doc_get_desc_fn

    def __new__(cls, *args, **kwargs) -> Self:
        instance = super().__new__(cls)

        if len(args) == 0:
            # In this case, __call__ will be called automatically and
            return instance
        else:
            instance.__init__(*args[1:], **kwargs)
            return instance(args[0])

    def _process_configurable(self, cls: type[T], configs: tuple[C, ...]):
        if len(configs) == 0:
            warnings.warn(
                f"No configs are found for {cls.__name__}. Either:"
                "\n    * Provide any config classes as arguments to the decorator, e.g."
                ", @configurable(config=MyConfig) or @configurable(config=(Cfg1, Cfg2))"
                '\n    * Specify base ("parent") config classes'
                "\n    * Specify inner config classes"
                "\nFor the latter two cases, unless you use a custom `is_config` "
                "function check, please ensure every config class is a dataclass and "
                "its name contains the word 'config' (case-insensitive) with no "
                "lowercase alphabetic character afterwards. Some examples of valid "
                "config class names are: 'Config', 'config_1', 'MyCoNfIgIsCool', "
                "'Config69'. Examples of invalid config class names are: 'Conf', "
                "'configg', 'MyCoNfIgisCool'.",
                UserWarning,
            )

            return cls

        # Convert config classes to ConfigParams objects
        configs = [
            ConfigParams(
                config,
                propagate_kwargs=self.propagate_kwargs,
                doc_desc_newline=self.doc_desc_newline,
                doc_type_max_depth=self.doc_type_max_depth,
                doc_get_desc_fn=self.doc_get_desc_fn,
            )
            for config in configs
        ]

        # Set default config params and assign method for this class
        setattr(cls, _ASSIGN_PARAMS, Configurable.__assign_params__)
        setattr(cls, _CONFIG_PARAMS, configs)

        if is_dataclass(cls):
            # These methods can be auto-generated by dataclasses. We
            # need to regenerate them as they may still contain info
            # from the config bases (which were dynamically removed)
            GENERATABLE_METHODS = {
                "__init__",
                "__repr__",
                "__eq__",
                "__lt__",
                "__le__",
                "__gt__",
                "__ge__",
                "__hash__",
                "__match_args__",
            }

            for method_name in GENERATABLE_METHODS:
                if is_dynamically_created(cls, method_name):
                    # Can only be recreated if doesn't exist
                    delattr(cls, method_name)

            # Regenerate the dataclass with excluded config "parents"
            cls = dataclass(cls, **slots_to_dict(getattr(cls, _PARAMS)))

        if type(cls) is type:
            # Redefine the class but with the new metaclass
            cls = ConfigurableMeta(cls.__name__, cls.__bases__, dict(cls.__dict__))

        # Store the mapping between the configurable and its configs
        self.__class__.CONFIGURABLE_TO_CONFIG[cls] = tuple(configs)
        self.__class__.CONFIG_TO_CONFIGURABLE[
            tuple(c.config_class for c in configs)
        ].append(cls)

        return cls

    def wrap(self, cls):
        if self.config is None:
            # Lists to split bases
            configs, bases = [], []

            for base in cls.__bases__:
                # Append to either config base list or normal base list
                (configs if self.is_config(base) else bases).append(base)

            for k in cls.__dict__.keys() if hasattr(cls, "__dict__") else cls.__slots__:
                if k.startswith("__") and k.endswith("__"):
                    continue

                if isinstance(v := getattr(cls, k, None), type) and self.is_config(v):
                    # Inner config cls
                    configs.append(v)

            class Dummy:
                pass

            # Assign non-config bases, keep configs
            setattr(cls, "__bases__", tuple(bases) if bases else (Dummy,))
            configs = tuple(configs)
        elif isinstance(self.config, Iterable):
            # Ensure it is a tuple
            configs = tuple(self.config)
        else:
            # Convert to tuple
            configs = (self.config,)

        return self._process_configurable(cls, configs)

    @overload
    def __call__[T](self, _: T) -> T | C: ...

    @overload
    def __call__(self, *args, **kwargs) -> T: ...

    def __call__(self, *args, **kwargs):
        if self.cls is None:
            # Called as @configurable()
            self.cls = args[0]
            args = args[1:]
            return self.wrap(self.cls)

        # Called as @configurable without parens
        return self.wrap(self.cls)(*args, **kwargs)


class ConfigurableMeta(type):
    # NOTE: setting config params in __new__ would not work because
    # config kwargs might not be popped out and init would complain
    def __call__[T](cls: type[T], *args, **kwargs) -> T:
        try:
            # Create the instance via its __new__ method
            instance = cls.__new__(cls, *args, **kwargs)
        except TypeError:
            # Probably no __init__ method
            instance = cls.__new__(cls)

        if isinstance(instance, cls) and hasattr(cls, _ASSIGN_PARAMS):
            # Assign the config params before calling the __init__
            kwargs = getattr(instance, _ASSIGN_PARAMS)(**kwargs)

            # Filter out config parameters that were already assigned
            # kwargs = {k: v for k, v in kwargs.items() if k not in assigned}

            # if is_dataclass(cls) and hasattr(cls, "__init__"):
            # remove_dataclass_init_params(instance, assigned.keys())
            # If this configurable (cls) is a dataclass, and the
            # decorator order is @configurable -> @dataclass, and
            # the configs were extended by the configurable, e.g.,
            # class MyConfigurable(MyConfig1, MyConfig2), then
            # @dataclass automatically created an __init__ such
            # that it requires all parent fields, even the ones
            # from the configs, despite them not actually being
            # parents. This bit of code inspects the __init__ and
            # adds back the missing fields to filtered kwargs - the
            # fields were already assigned and will simply be
            # reassigned in this case.

            # for param_name in cls.__init__.__code__.co_varnames:
            #     if param_name not in kwargs and param_name in assigned:
            #         # Possibly an already set "parent" config field
            #         kwargs[param_name] = assigned[param_name]

            # if is_dataclass(cls) and hasattr(cls, "__post_init__"):
            # Similar to previous block, but here we need to remove
            # any InitVars that belong to configs rather than this
            # configurable from the __post_init__ signature
            # pass

        if isinstance(instance, cls) and hasattr(cls, "__init__"):
            # Now call the original __init__ method
            cls.__init__(instance, *args, **kwargs)

        return instance


class Configurable(Protocol):
    __config_params__: tuple[ConfigParams, ...] = ()

    def __assign_params__(self, **kwargs) -> dict[str, Any]:
        # Get configs with default params and deepcopy for this instance
        configs = configurable.CONFIGURABLE_TO_CONFIG.get(self.__class__)
        configs = copy.deepcopy(configs)
        # assigned = {}

        if configs is None:
            return

        for config in configs:
            # Update the config with kwargs and convert to dataclass
            # Must call `as_dataclass` due to possible __post_init__
            used_keys = config.update(kwargs, ignore_unknown=True)
            [kwargs.pop(key) for key in used_keys]
            dataclass_cfg = config.as_dataclass()

            for name, value in asdict(dataclass_cfg).items():
                # Call `setattr` instead of directly updating __dict__
                # because, for example, the configurable may use slots
                setattr(self, name, value)

            # for name in used_keys:
            # Just copy the final assigned value. Some InitVars
            # were not assigned but we add them for convenience
            # assigned[name] = getattr(self, name, kwargs[name])

        # Reassign _CONFIG_PARAMS (as instance attr)
        setattr(self, _CONFIG_PARAMS, tuple(configs))

        return kwargs
