Metadata-Version: 2.1
Name: muzlin
Version: 0.0.1
Summary: Muzlin: a filtering toolset for semantic machine learning
Author: Daniel Kulik
Maintainer: Daniel Kulik
License: MIT License
        
        Copyright (c) 2024 Daniel Kulik
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
Keywords: RAG,outlier-detection,filtering,retrieval,semantic,ML,LLM,NLP
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Customer Service
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Science/Research
Classifier: Intended Audience :: Telecommunications Industry
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Software Development
Classifier: Topic :: Software Development :: Embedded Systems
Classifier: Topic :: Communications :: Chat
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Text Processing
Classifier: Topic :: Text Processing :: Filters
Classifier: Topic :: Text Processing :: Indexing
Classifier: Operating System :: POSIX :: Linux
Classifier: Operating System :: MacOS
Classifier: Operating System :: Microsoft :: Windows
Requires-Python: >=3.8
Description-Content-Type: text/x-rst
License-File: LICENSE
Requires-Dist: apipkg
Requires-Dist: colorlog
Requires-Dist: huggingface-hub
Requires-Dist: joblib>=0.14.1
Requires-Dist: numpy<=1.26.4
Requires-Dist: pydantic>=2.0
Requires-Dist: pyod>=1.0.0
Requires-Dist: pythresh>=0.3.0
Requires-Dist: scikit-learn>=0.20.0
Requires-Dist: scipy>=1.3.1
Requires-Dist: torch
Requires-Dist: transformers
Requires-Dist: tokenizers
Requires-Dist: umap-learn
Provides-Extra: dev
Requires-Dist: pytest; extra == "dev"
Requires-Dist: pytest-cov; extra == "dev"
Requires-Dist: flake8; extra == "dev"
Requires-Dist: mypy; extra == "dev"
Requires-Dist: typed-ast; extra == "dev"
Requires-Dist: pydocstringformatter; extra == "dev"
Requires-Dist: ruff; extra == "dev"
Requires-Dist: autopep8; extra == "dev"
Requires-Dist: isort; extra == "dev"
Requires-Dist: openai<2.0.0,>=1.10.0; extra == "dev"
Requires-Dist: cohere<6.00,>=5.00; extra == "dev"
Requires-Dist: boto3; extra == "dev"
Requires-Dist: botocore; extra == "dev"
Requires-Dist: fastembed; extra == "dev"
Requires-Dist: google-cloud-aiplatform; extra == "dev"
Requires-Dist: mlflow; extra == "dev"
Requires-Dist: llama-index-embeddings-huggingface; extra == "dev"
Requires-Dist: llama-index; extra == "dev"
Requires-Dist: faiss-cpu; extra == "dev"
Requires-Dist: langchain-community; extra == "dev"
Requires-Dist: sentence-transformers; extra == "dev"
Requires-Dist: networkx; extra == "dev"
Requires-Dist: pygod; extra == "dev"
Requires-Dist: torch-geometric; extra == "dev"
Requires-Dist: torch-scatter; extra == "dev"
Requires-Dist: torch-sparse; extra == "dev"
Requires-Dist: torch-cluster; extra == "dev"
Requires-Dist: torch-spline-conv; extra == "dev"
Provides-Extra: graph
Requires-Dist: networkx; extra == "graph"
Requires-Dist: pygod; extra == "graph"
Requires-Dist: torch-geometric; extra == "graph"
Requires-Dist: torch-scatter; extra == "graph"
Requires-Dist: torch-sparse; extra == "graph"
Requires-Dist: torch-cluster; extra == "graph"
Requires-Dist: torch-spline-conv; extra == "graph"
Provides-Extra: notebook
Requires-Dist: mlflow; extra == "notebook"
Requires-Dist: umap-learn; extra == "notebook"
Requires-Dist: pandas; extra == "notebook"
Requires-Dist: faiss-cpu; extra == "notebook"
Requires-Dist: langchain-community; extra == "notebook"
Requires-Dist: sentence-transformers; extra == "notebook"
Requires-Dist: matplotlib; extra == "notebook"
Requires-Dist: plotly; extra == "notebook"
Requires-Dist: datasets; extra == "notebook"
Requires-Dist: pygod; extra == "notebook"
Requires-Dist: torch-geometric; extra == "notebook"

########
 Muzlin
########

*When a filter cloth üè≥Ô∏è is needed rather than a simple RAG üè¥‚Äç‚ò†*

*************
 What is it?
*************

Muzlin merges classical ML techniques with complex generative AI. It's
goal is to apply simple, efficent, and effective methods for filtering
many aspects of the generative text process train. These methods address
the following questions:

-  Does a RAG/GraphRAG have any context to answer the user's question?

-  Does the retrieved context contain good candidates to provide a
   complete answer (e.g. are the retrieved context too dense/sparse)?

-  Does the generated LLM response deviate from the provided context?
   (Hallucination)

-  Given a collection of questions, should an extracted portion of text
   be added to an existing RAG with respect to its ability to answer any
   of the questions in the collection?

-  Given an existing RAG, what is the probability that a new portion of
   text belongs to the RAG cluster?

-  Given a collection of embedded text (e.g. context, user question and
   answers, synthetic generated data, etc...), what components are
   considered inliers and outliers?

Muzlin is dynamic and production ready and can be added as a
decision-making layer for any LLM and agentic process flows.

**Note** while Muzlin is production ready, it is still in a development
phase and is subject to significant changes!

************
 Quickstart
************

To get started use **pip** for installation:

.. code:: bash

   pip install muzlin

In order to compared text, we need to first create a base of
information. To do this we need a collection of text embeddings:

.. code:: python

   import numpy as np
   from muzlin.encoders import HuggingFaceEncoder

   encoder = HuggingFaceEncoder()

   vectors = encoder(texts) # where texts is a list of str
   vectors = np.array(vectors)
   np.save('vectors', vectors)

Next we will construct an unsupervised anomaly detection model using the
embedded vectors:

.. code:: python

   import mlflow as ml # optional
   from muzlin.anomaly import OutlierDetector
   from pyod.models.pca import PCA

   # Read in vectors
   vectors = np.load('vectors.npy')

   # Initialize OD and thresholding model
   od = PCA(contamination=0.02)

   ml.set_experiment('outlier_model')
   clf = OutlierDetector(mlflow=True, detector=od)
   clf.fit(vectors)
   ml.end_run()

This anomaly model can be either logged using mlflow or simply as a
joblib file.

**Note** that a simpler encoder e.g. 384 dimesions leads to a "fuzzy"
outlier detector that is generally less strict and increases the
probability that new text and the embedded collection of text will have
a closer similarity. Higher dimesion encoder models can be used for a
dense embedded space e.g. over 2000 vectors or for strict settings e.g.
Medicine, but note that embedding time increases as well. Also, small
text collections <100 or collections with a wide range of topics may
degrade the filtering capabilities

Now that we have an anomaly model we can filter new incoming text. Here
is an example for a RAG setting:

.. code:: python

   from muzlin.anomaly import OutlierDetector
   from muzlin.encoders import HuggingFaceEncoder

   # Preload trained model - or load with joblib
   clf = OutlierDetector(model='outlier_detector.pkl')

   # Encode question
   encoder = HuggingFaceEncoder()

   vector = encoder(['Who was the first man to walk on the moon?'])
   vector = np.array(vector).reshape(1,-1) # Must be 2D

   # Get a binary inlier 0 or outlier 1 output
   label = clf.predict(vector)

The example above is just a quick dive into the capabilities of Muzlin.
Go check out the example notebooks for a more in depth tutorial on all
the different kinds of methods and possible applications.

***************
 Intergrations
***************

Muzlin supports the use of many libraries for both vector and graph
based setups, and is fully intergrated with MLFlow for model tracking
and Pydantic for validation.

+-----------------------------------+-------------------------+----------------------+
| Anomaly detection                 | Encoders                | Vector Index         |
+===================================+=========================+======================+
| -  Scikit-Learn                   | -  HuggingFace          | -  LangChain         |
| -  PyOD (vector)                  | -  OpenAI               | -  LlamaIndex        |
| -  PyGOD (graph)                  | -  Cohere               |                      |
| -  PyThresh (thresholding)        | -  Azure                |                      |
|                                   | -  Google               |                      |
|                                   | -  Amazon Bedrock       |                      |
|                                   | -  Fastembed            |                      |
+-----------------------------------+-------------------------+----------------------+

----

***********
 Resources
***********

**Table of notebooks**

+---------------------------+------------------------------------------------------------------------------------------------------+
| Notebook                  | Description                                                                                          |
+===========================+======================================================================================================+
| Introduction              | Data prep and a simple semantic vector-based outlier detection model                                 |
+---------------------------+------------------------------------------------------------------------------------------------------+
| Optimal Threshold         | Methods for optimal threshold selection (unsupervised, semi-supervised, supervised)                  |
+---------------------------+------------------------------------------------------------------------------------------------------+
| Cluster-Based Filtering   | Using clustering to decide if retrieved documents can answer a user's question                       |
+---------------------------+------------------------------------------------------------------------------------------------------+
| Graph-Based Filtering     | Using graph based anomaly detection for filtering semantic graph-based systems (e.g. GraphRAG)       |
+---------------------------+------------------------------------------------------------------------------------------------------+

************
 What Else?
************

Besides Muzlin there are also many other great libraries that can help
to increase a generative AI process flow. Check out `Semantic Router
<https://github.com/aurelio-labs/semantic-router>`_, `CRAG
<https://github.com/HuskyInSalt/CRAG>`_, and `Scikit-LLM
<https://github.com/iryna-kondr/scikit-llm>`_

----

**************
 Contributing
**************

**Note** at the moment their are major changes being done and the
structure of Muzlin is still being refined. For now, please leave a bug
report and potential new code for any fixes or improvements. You will be
added as a co-author if it is implemented.

Once this phase has been completed then ->

Anyone is welcome to contribute to Muzlin:

-  Please share your ideas and ask questions by opening an issue.

-  To contribute, first check the Issue list for the "help wanted" tag
   and comment on the one that you are interested in. The issue will
   then be assigned to you.

-  If the bug, feature, or documentation change is novel (not in the
   Issue list), you can either log a new issue or create a pull request
   for the new changes.

-  To start, fork the **dev branch** and add your
   improvement/modification/fix.

-  To make sure the code has the same style and standard, please refer
   to detector.py for example.

-  Create a pull request to the **dev branch** and follow the pull
   request template `PR template
   <https://github.com/KulikDM/muzlin/blob/main/.github/PULL_REQUEST_TEMPLATE.md>`_

-  Please make sure that all code changes are accompanied with proper
   new/updated test functions. Automatic tests will be triggered. Before
   the pull request can be merged, make sure that all the tests pass.
