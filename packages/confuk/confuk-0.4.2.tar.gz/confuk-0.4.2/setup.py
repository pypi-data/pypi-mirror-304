# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['confuk']

package_data = \
{'': ['*']}

install_requires = \
['easydict>=1.11,<2.0',
 'omegaconf>=2.3.0,<3.0.0',
 'pydantic>=2.5.3,<3.0.0',
 'rich>=13.8.1,<14.0.0',
 'ruamel-yaml>=0.18.6,<0.19.0',
 'toml>=0.10.2,<0.11.0']

setup_kwargs = {
    'name': 'confuk',
    'version': '0.4.2',
    'description': 'Very opinionated configuration loading package for Python projects',
    'long_description': '<img src="confuk-logo.drawio.png" width=150/>\n\n# Confuk\n\nThis is yet another package for managing configuration files in Python projects.\n\nIt exposes one function that lets you provide a path to a TOML/YAML/JSON configuration file. It parses the config file into a dictionary by default. If a config class is provided when parsing, the class instance will be created using a dictionary of keyword arguments coming from the original TOML/YAML/JSON file.\n\nIn human words: I made this package so that I don\'t have to explicilty load, parse and return a class instance every single time I have something to do with a configuration file:\n\n```python\nfrom confuk import parse_config\nfrom pathlib import Path\nfrom somewhere import ConfigClass\n\ncfg_dict = parse_config(Path("some.toml"))  # returns a dictionary\ncfg_obj = parse_config(Path("some.toml"), ConfigClass)  # returns an instance of `ConfigClass`\n```\n\n> [!tip]\n> `confuk` also supports a number of output configuration styles out-of-the-box, including `omegaconf`, Pydantic and `EasyDict`.\n\n## Installation\n\n```bash\npip install confuk\n```\n\nOr:\n\n```bash\npoetry add confuk\n```\n\n### Building from source\n\nYou can build the package using Poetry:\n\n1. Clone this repo.\n2. Run `poetry build`.\n3. Grab the installable wheel from the `dist` folder and install it with `pip` or add the package as a local dependency of another project.\n\n## Special features\n\n### Config output formats\n\n#### EasyDict\n\nIf you really hate referring to dictionary keys and you do not intend to create a custom configuration class for your config, you can parse the file to an `EasyDict`:\n\n```python\ncfg_edict = parse_config(Path("some.toml"), "attr")\n```\n\nNow, if the key `something` exists in the configuration file, you can simply refer to it using an attribute:\n\n```python\ncfg_edict.something\n```\n\n#### OmegaConf\n\n[OmegaConf](https://omegaconf.readthedocs.io/) is one of the most complete configuration systems for Python applications. If you want to leverage its features while still working with `confuk` as a front-end, you can simply parse the configuration into an instance of `omegaconf.DictConfig` by doing the following:\n\n```python\ncfg = parse_config(Path("some.toml"), "omega")\n```\n\n#### Pydantic\n\nIf you\'re a fan of [Pydantic](https://docs.pydantic.dev/latest/) with custom config classes for automatic validation, just use any class that inherits from `BaseModel`:\n\n\n```python\nfrom confuk import parse_config\nfrom pathlib import Path\nfrom pydantic import BaseModel\n\nclass Metrics(BaseModel):\n    psnr: float\n    ssim: float\n\n\ncfg_dict = parse_config(Path("some.toml"), Metrics)  # returns a dictionary\n```\n\n#### All currently supported formats\n\n| Format      | `cfg_class` argument                               |\n| ----------- | -------------------------------------------------- |\n| `dict`      | `"d"` / `None`                                     |\n| `EasyDict`  | `"ed"` / `"edict"` / `"attr"`                      |\n| `OmegaConf` | `"o"` / `"omega"` / `"omegaconf"`                  |\n| `pydantic`  | `BaseModel` class                                  |\n| `custom`    | any class supporting `**kwargs` in the constructor |\n\n### Imports\n\nBecause keeping hundreds of config files can become tedious, especially when there is shared values between them, you might want to consider using the `imports` functionality.\n\nSay you have a TOML file from which you want to inherit values:\n\n```toml\n[something]\nvalue = 1\nanother_value = 2\n\n[something_else]\nvalue = 3\n```\n\nYou can "import" it using a preamble:\n\n```toml\n[pre]\nimports = [\n    "${this_dir}/test_imported.toml",\n]\n\n[something]\nvalue = 69\n```\n\n> [!note]\n> Older versions of `confuk` used the `$this_dir` syntax instead. This will be supported going into the future but it won\'t work with variable interpolation (expect it to only work for the special interpolation markers such as `$this_dir` and `$cwd`).\n\nThis is equivalent to specifying a config like:\n\n```toml\n[something]\nvalue = 69\nanother_value = 2\n\n[something_else]\nvalue = 3\n```\n\nNote that you can use several special interpolation markers to specify paths in the import section:\n\n- `${this_dir}` -> points to a directory relative to the configuration file that contains the `import` section\n- `${cwd}` -> points to the current working directory\n- `${this_filename}` -> config filename (with extension)\n- `${this_filename_stem}` -> filename without the extension (stem)\n- `${this_dirname}` -> the name of the directory where the configuration file lives (not a path)\n- `${this_filename_suffix}` -> suffix (without the dot) of the current configuration file\n\n> [!warning]\n> The preamble **will be removed** after it\'s processed. It\'s there only to control how `confuk` should process the loaded configuration files and it\'s dropped afterwards. Do not put any meaningful configuration into your preamble, except for `confuk`\'s control elements.\n\n#### What about inheriting selected values?\n\nUnsupported. And I do not plan to add support for cherrypicking values from other configs. It makes things way messier in my opinion, as it becomes way harder to reason about the flow of variables.\n\n#### What about variable interpolation?\n\nThis is supported with the syntax that [OmegaConf](https://omegaconf.readthedocs.io/) uses, e.g. `path = "${some.root.path}/file.txt"` will pick up the `path` variable from `some.root` config section. The interpolation markers that I mentioned in the `Imports` section should also work anywhere else within the config, so you can use your `${this_filename_stem}` to refer to config names within the config itself. One use-case is when you want to have subdirectories in a `results` directory, where you would silo away the results from different configs:\n\n```toml\nresults_dir = "results/${this_filename_stem}"\n```\n\nAssumming that you have 3 configs for your experiments: `ex1`, `ex2` and `ex3`, you could instead put `results_dir` in a parent config to all those:\n\n```toml\n# to_import.toml:\nresults_dir = "results/${this_filename_stem}"\n\n# ex1\n[pre]\nimports = ["${this_dir}/to_import.toml"]\na_variable_that_diverges_across_configs = 69\n\n# ex2\n[pre]\nimports = ["${this_dir}/to_import.toml"]\na_variable_that_diverges_across_configs = 420\n\n# ex3\n[pre]\nimports = ["${this_dir}/to_import.toml"]\na_variable_that_diverges_across_configs = 42\n```\n\n> [!note]\n> We are using `omegaconf` for all other interpolation tasks under the hood since they already have a great parser for this and there\'s no use duplicating work.\n\n#### What about deeply nested configs?\n\nIf you like the deeply nested folder-file structure for your configs then [Hydra](https://hydra.cc/) might be more for you. I\'ve used it before and it\'s very good but I personally find the design choice of creating directory structures for configs quite tedious.\n\n`confuk` strives to be flatter: you import another config file in the preamble section and you have a choice of what to override. This makes it more comfortable to use when you have one `default.toml` config file for something and then create a bunch of configurations overriding certain values. This is useful for experiments in the AI/ML space, where I\'m spending most of my time now.\n\nYou are of course free to structure your files as you please but don\'t expect a feature similar to Hydra\'s `defaults` in `confuk` â€“ I do indeed use Hydra for applications which require such a system!\n\n### Command-line overrides\n\nOne of the most fantastic features I\'ve found when using [Hydra](https://hydra.cc/) was the ability to override values from the config file on the command line. This is convenient when you want to quickly test some changes to your configuration without going through the trouble of creating a new config file.\n\nSo I concluded it would be fun to implement it in `confuk` in a similar fashion. Here\'s how it works:\n\n```python\nimport confuk\n\n\n@confuk.main(config=Path(__file__).parent / "test.toml", config_format="o", verbose=False)\ndef main(cfg, *args):\n    console = Console()\n    console.print(cfg)\n    return cfg\n```\n\nThis decorator behaves similarly to `@hydra.main` decorator and it creates a minimal argument parser for your application entrypoint under the hood.\n\nNow, when running the app, you can specify any value overrides on the command line. For example if your config looks like this:\n\n```toml\n[my]\nmother = 1\n\n[your.dad]\nfather = 1\n```\n\nAnd you run your CLI app with the argument `your.dad.father=3`, you will override the pertinent value from `1` to `3`.\n\n> [!tip]\n> The underlying argument parser also contains a `--config` option. You can use it to switch to a different config path on the command line, without a need to rely on the default one that has been set in the decorator.\n',
    'author': 'Krzysztof J. Czarnecki',
    'author_email': 'kjczarne@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
