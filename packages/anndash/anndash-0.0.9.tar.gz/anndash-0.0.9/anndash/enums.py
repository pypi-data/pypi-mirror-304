"""enums module for `anndash`"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_enums.ipynb.

# %% auto 0
__all__ = []

# %% ../nbs/03_enums.ipynb 4
import os, re, io, yaml
from pathlib import Path
from inspect import isfunction, ismethod
from importlib_resources import files
try: from enum import StrEnum, auto
except ImportError: from enum import Enum

try: 
    from typing import Any, Sequence, TypeAlias
except ImportError:
    from typing_extensions import Any, Sequence, TypeAlias
        
import numpy as np, pandas as pd

try: from sklearn.preprocessing import MinMaxScaler
except ImportError: ...

# %% ../nbs/03_enums.ipynb 5
from .hints import (Strings, DataLike, Pattern, PatternQ, Flags, MatchQ)
from .utils import (str_imatch)

# %% ../nbs/03_enums.ipynb 7
try:
    class ColorDType(StrEnum):
        '''Color datatypes'''
        OBJECT = auto()
        STRING = auto()
        NUMBER = auto()
        BOOLEAN = auto()
        CATEGORY = auto()
        DATETIME = auto()
        UNKNOWN = auto()
        
        @classmethod
        def _missing_(cls, value: str) -> 'ColorDType':
            for k, v in cls._member_map_.items():
                if str_imatch(value, v.value) or str_imatch(value, v.name): return cls(v)
            return cls.UNKNOWN
        
        def __call__(self, string: str) -> bool:
            return bool(str_imatch(string, self.value))
except:
    class ColorDType(Enum):
        '''Color datatypes'''
        OBJECT = 'object'
        STRING = 'string'
        NUMBER = 'number'
        BOOLEAN = 'boolean'
        CATEGORY = 'category'
        DATETIME = 'datetime'
        UNKNOWN = 'unknown'
        
        @classmethod
        def _missing_(cls, value: str) -> 'ColorDType':
            for k, v in cls._member_map_.items():
                if str_imatch(value, v.value) or str_imatch(value, v.name): return cls(v)
            return cls.UNKNOWN
        
        def __call__(self, string: str) -> bool:
            return bool(str_imatch(string, self.value))

# %% ../nbs/03_enums.ipynb 8
try:
    class DTypePattern(StrEnum):
        '''RegEx patterns for Pandas / Numpy'''
        
        OBJECT = r'^(object).*'
        '''object regex pattern'''
        
        STRING = r'^(u?)(str|utf|byte).*'
        '''string regex pattern'''
        
        NUMBER = r'^(u?)(int|float|complex|number|long|short|double).*'
        '''number regex pattern'''
        
        BOOLEAN = r'^(bool|boolean).*'
        '''boolean regex pattern'''
        
        CATEGORY = r'^(category|categorical).*'
        '''categorical regex pattern'''
        
        DATETIME = r'^(date|time).*'
        '''date / time regex pattern''';
        
        UNKNOWN = r'.*'
        
        def pattern(self: 'DTypePattern') -> re.Pattern[str]:
            '''Returns the instance of this `enum` as a `re.Pattern`.'''
            return str(self.value)
        
        def match(
            self: 'DTypePattern', 
            string: str, 
            flags: re.RegexFlag = re.RegexFlag.IGNORECASE,
            check_name: bool = True
        ) -> re.Match[str] | None:
            '''Returns the match found of `string` for this `enum` when used as a `re.Pattern`
            i.e. `re.match(self.pattern(), string, flags)`. Use `check_name` to fallback to the
            instance of this enum's name if `self.pattern()` is not found.
            '''
            found = re.match(self.pattern(), string, flags)
            if not found and check_name: return re.match(str(self.name), string, flags)
            return found
        
        def imatch(self: 'DTypePattern', string: str, check_name: bool = True) -> re.Match[str] | None:
            '''Returns the match found of `string` for this `enum` when used as a `re.Pattern`
            i.e. `re.match(self.pattern(), string, flags=re.RegexFlag.IGNORECASE)`. Use `check_name` 
            to fallback to the instance of this enum's name if `self.pattern()` is not found.
            '''
            return self.match(string, flags=re.RegexFlag.IGNORECASE, check_name=check_name)
        
        @classmethod
        def _missing_(cls, value: str) -> 'DTypePattern':
            for k, v in cls._member_map_.items():
                if v.imatch(value, True): return cls(v)
                # if str_imatch(value, v): return cls(v)
                # if str_imatch(value, k): return cls(v)
                # if v == value: return cls(v)
                # if k == value: return cls(v)
            return cls.UNKNOWN    
        
        def __call__(self, string: str) -> bool:
            return bool(str_imatch(string, self.value))
except:
    class DTypePattern(Enum):
        '''RegEx patterns for Pandas / Numpy'''
        
        OBJECT = r'^(object).*'
        '''object regex pattern'''
        
        STRING = r'^(u?)(str|utf|byte).*'
        '''string regex pattern'''
        
        NUMBER = r'^(u?)(int|float|complex|number|long|short|double).*'
        '''number regex pattern'''
        
        BOOLEAN = r'^(bool|boolean).*'
        '''boolean regex pattern'''
        
        CATEGORY = r'^(category|categorical).*'
        '''categorical regex pattern'''
        
        DATETIME = r'^(date|time).*'
        '''date / time regex pattern''';
        
        UNKNOWN = r'.*'
        
        def pattern(self: 'DTypePattern') -> re.Pattern[str]:
            '''Returns the instance of this `enum` as a `re.Pattern`.'''
            return str(self.value)
        
        def match(
            self: 'DTypePattern', 
            string: str, 
            flags: re.RegexFlag = re.RegexFlag.IGNORECASE,
            check_name: bool = True
        ) -> re.Match[str] | None:
            '''Returns the match found of `string` for this `enum` when used as a `re.Pattern`
            i.e. `re.match(self.pattern(), string, flags)`. Use `check_name` to fallback to the
            instance of this enum's name if `self.pattern()` is not found.
            '''
            found = re.match(self.pattern(), string, flags)
            if not found and check_name: return re.match(str(self.name), string, flags)
            return found
        
        def imatch(self: 'DTypePattern', string: str, check_name: bool = True) -> re.Match[str] | None:
            '''Returns the match found of `string` for this `enum` when used as a `re.Pattern`
            i.e. `re.match(self.pattern(), string, flags=re.RegexFlag.IGNORECASE)`. Use `check_name` 
            to fallback to the instance of this enum's name if `self.pattern()` is not found.
            '''
            return self.match(string, flags=re.RegexFlag.IGNORECASE, check_name=check_name)
        
        @classmethod
        def _missing_(cls, value: str) -> 'DTypePattern':
            for k, v in cls._member_map_.items():
                if v.imatch(value, True): return cls(v)
                # if str_imatch(value, v): return cls(v)
                # if str_imatch(value, k): return cls(v)
                # if v == value: return cls(v)
                # if k == value: return cls(v)
            return cls.UNKNOWN    
        
        def __call__(self, string: str) -> bool:
            return bool(str_imatch(string, self.value))
