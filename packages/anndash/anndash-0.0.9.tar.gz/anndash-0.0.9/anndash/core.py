"""Core module for `anndash`"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_core.ipynb.

# %% auto 0
__all__ = ['AnnDashboard']

# %% ../nbs/10_core.ipynb 4
import os, re, io, yaml
from importlib_resources import files

try:
    from typing import Any, Sequence, TypeAlias
except ImportError:
    from typing_extensions import Any, Sequence, TypeAlias
    
from enum import StrEnum, auto
from pathlib import Path

# widgets
from IPython.display import display
import ipywidgets as widgets

# data analysis packages
import pandas as pd, numpy as np
from sklearn.preprocessing import MinMaxScaler

# single cell packages
import anndata as ad

# plotting packages
import matplotlib as mpl, matplotlib.pyplot as plt, seaborn as sns
import plotly.graph_objects as go, plotly.express as px

from dash import Dash, dcc, html, Input, Output, State
import dash.development.base_component as ddbc
import dash_bootstrap_components as dbc

# %% ../nbs/10_core.ipynb 5
from .hints import AnnOption
from .utils import filter_matches
from .color import extract_colors

# %% ../nbs/10_core.ipynb 7
class AnnDashboard:
    def __init__(self, adata: ad.AnnData, *args, **kwargs):
        # Initialize Dash app
        self._app: Dash = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])
        
        gene_col = kwargs.pop('gene_col', 'gene_symbol')
        if gene_col not in adata.var_keys(): 
            gene_col = None
            
        self.layer_keys: list[str] = list(adata.layers.keys())
        self.basis_keys: list[str] = filter_matches(adata.obsm_keys(), r'^X_')
        
        self.gene_items = self._make_gene_items(adata, gene_col)
        
        self.obs_options = adata.obs_keys()
        self.var_options = adata.var_keys()
        self.dim_default = [dict(label=str(i), value=i) for i in range(3)]
        self.dim_options = self.dim_default
        
        self._basis = None
        self._fig = None
        self._make_layout()
        self._make_callbacks(adata) 
            
    
    def _make_gene_items(self, adata: ad.AnnData, gene_col: str | None = None) -> list[dict[str,str]]:
        genes = []
        
        for index in adata.var.index:
            label = getattr(index, 'value', index)
            item = dict(label=label, value=index)
            
            if gene_col in adata.var_keys():
                value = adata.var.loc[index, gene_col]
                label = getattr(value, 'value', value)
                item.update(label=label)
            
            genes.append(item)
            
        return genes
            
    def _make_select(
        self,
        id: str, 
        keys: list[str], 
        extra: list[dict] | None = None,                 
        select: ddbc.Component | str = 'Dropdown',
        default = None, 
        use_key = False,
        suffix: str | None = '_dropdown',
        **kwargs
    ):
        options = [dict(label=key, value=key) for key in keys]
        options += ([extra] if isinstance(extra, dict) else extra if (extra and len(extra)) else [])
        
        html_id = f'{id}{suffix}' if suffix else id
        
        if not use_key or use_key and not keys: default = (default or None)
        
        if use_key and isinstance(keys, list) and len(keys):
            default = keys[0] 
            
        if isinstance(default, dict):
            default = default.get('value', default)
        
        if isinstance(select, str): 
            select = dcc.Dropdown
        
        return select(id=html_id, options=options, value=default, **kwargs)
        
    def _make_radios(
        self, id: str, keys: list[str], extra: list[dict] | None = None,         
        default = None, use_key = False, suffix: str | None = '_radios', **kwargs
    ) -> dcc.RadioItems:
        return self._make_select(id, keys, extra, dcc.RadioItems, default, use_key, suffix, **kwargs)    
    
    def _make_drowdown(
        self, 
        id: str, keys: list[str], extra: list[dict] | None = None,         
        default = None, use_key = False, suffix: str | None = '_dropdown', **kwargs
    ) -> dcc.Dropdown:
        return self._make_select(id, keys, extra, dcc.Dropdown, default, use_key, suffix, **kwargs)
        
    def _make_layout(self):
        # Layout
        self._app.layout = dbc.Container([
            dbc.Row([
                dbc.Col([
                    html.H3("Embedding Basis"),
                    self._make_drowdown('basis', self.basis_keys, use_key=True),
                ], width=3),
                dbc.Col([
                    html.H3("Layer"),
                    self._make_drowdown(
                        'layer', self.layer_keys, extra=dict(label='X (default)', value='X'), default='X',
                        placeholder='Select a layer if other than X',
                    ),
                ], width=3),
                dbc.Col([
                    html.H3("Color By"),
                    self._make_radios('color_by', ['obs', 'gene'], default='gene', use_key=False, labelStyle={'display': 'block'}),
                ], width=3),
                dbc.Col([
                    html.H3("Plot Dims"),
                    self._make_radios('plot_dims', ['2D', '3D'], default='3D', use_key=False, labelStyle={'display': 'block'}),
                ], width=3),
            ]),
            dbc.Row([
                dbc.Col([
                    html.H3("Color Variable"),
                    dcc.Dropdown(
                        id='color_var_dropdown',
                        options=self.obs_options,
                        value=None,
                        multi=False
                    ),
                ], width=6),
                dbc.Col([
                    html.H3("Gene Selection"),
                    dcc.Dropdown(
                        id='gene_dropdown', 
                        options=self.gene_items, 
                        value=self.gene_items,
                        multi=False, 
                        placeholder='Select a gene',
                    ),
                ], width=6),
            ]),
            dbc.Row([
                dbc.Col([
                    html.H3("X Axis"),
                    dcc.Dropdown(id='x_axis_dropdown', options=self.dim_options, value=0)
                ], width=3),
                dbc.Col([
                    html.H3("Y Axis"),
                    dcc.Dropdown(id='y_axis_dropdown', options=self.dim_options, value=1)
                ], width=3),
                dbc.Col([
                    html.H3("Z Axis"),
                    dcc.Dropdown(id='z_axis_dropdown', options=self.dim_options, value=2, disabled=True)
                ], width=3),
            ]),
            dbc.Row([
                dbc.Col([
                    dcc.Graph(id='embedding_plot')
                ])
            ])
        ], fluid=True)
        
        return self
    
    def _make_colors(self, adata: ad.AnnData, color_by: AnnOption, color_var, gene: str | None = None, layer: str | None = None):
        # Handle coloring
        match color_by:
            case 'obs': 
                # color = adata.obs[color_var]
                color = extract_colors(adata, color_var, annots=[color_by], layer=layer)
            case 'var': 
                color = extract_colors(adata, color_var, annots=[color_by], layer=layer)
            case 'gene':
                color = extract_colors(adata, gene, annots=['var'], layer=layer)
            case _: 
                if gene is not None:
                    color = extract_colors(adata, gene, layer=layer)
                else:
                    color = extract_colors(adata, color_var, layer=layer)
        return color
    
    def _make_plot(
        self, adata: ad.AnnData, basis, layer, color_by, color_var, 
        gene, plot_type, x_axis, y_axis, z_axis
    ) -> go.Figure | dict:
        if not basis or basis not in adata.obsm: return {}
        if layer == 'X': layer = None
        
        data = adata.obsm[basis]
        if data.shape[1] < 2: return {}
        
        colors = self._make_colors(adata, color_by, color_var, gene, layer)
        
        df = pd.DataFrame(
            dict(
                x=data[:, x_axis], 
                y=data[:, y_axis],
                z=data[:, z_axis] if plot_type == '3D' else None
            ), index=adata.obs_names
        )
        match plot_type:
            case '2D': 
                fig = px.scatter(df, x='x', y='y', color=colors, hover_data=[adata.obs_names])
            case '3D': 
                fig = px.scatter_3d(df, x='x', y='y', z='z', color=colors, hover_data=[adata.obs_names])
            case _: 
                fig = {}
        return fig
    
    def _make_callbacks(self, adata: ad.AnnData):
        @self._app.callback(
            Output('x_axis_dropdown', 'options'),
            Output('y_axis_dropdown', 'options'),
            Output('z_axis_dropdown', 'options'),
            Output('z_axis_dropdown', 'disabled'),
            Input('basis_dropdown', 'value'),
            Input('plot_dims_radios', 'value')
        )
        def update_axes_options(basis, plot_type):
            x_opts, y_opts, z_opts, z_off = [], [], [], True
            if not basis or basis not in adata.obsm:
                return x_opts, y_opts, z_opts, z_off
            
            
            dims = adata.obsm[basis].shape[1]
            name = basis.removeprefix('X_')
            
            options = [dict(label=f'{name}_{i}', value=i) for i in range(dims)]
            
            self._basis = basis
            # self._axis_options = options
            
            x_opts = options
            y_opts = options
            
            if dims >= 3 and plot_type == '3D': 
                z_opts, z_off = options, False
            
            return x_opts, y_opts, z_opts, z_off
    
    
        # what goes in the color_by column
        @self._app.callback(
            Output('color_var_dropdown', 'options'),
            Output('color_var_dropdown', 'value'),
            Output('gene_dropdown', 'disabled'),
            Input('color_by_radios', 'value')
        )
        def update_color_variable_options(color_by: str | None = None):
            gene_off = True
            match color_by:
                case 'gene':
                    options = [] # self.gene_items
                    value = options[0] if len(options) else None
                    gene_off = False
                case 'obs':
                    options = [{'label': col, 'value': col} for col in adata.obs.columns]
                    value = adata.obs.columns[0] if len(adata.obs.columns) > 0 else None
                case 'var':
                    options = [{'label': col, 'value': col} for col in adata.var.columns]
                    value = adata.var.columns[0] if len(adata.var.columns) > 0 else None
                    gene_off = False
                case _:
                    options = self.gene_items
                    value = None
            if isinstance(value, dict):
                value = value.get('value', value)
            return options, value, gene_off       
    
        @self._app.callback(
            Output('z_axis_dropdown', 'value'),
            Input('z_axis_dropdown', 'options')
        )
        def set_z_default(options):
            if options: 
                return 2 if len(options) > 2 else options[-1]['value']
            return None
    
        @self._app.callback(
            Output('plot_dims_radios', 'options'),
            Output('plot_dims_radios', 'value'),
            # Output('z_axis_dropdown', 'disabled'),
            Input('basis_dropdown', 'value')
        )
        def update_plot_type_options(basis):
            opts, value = [], '3D'
            if (not basis or basis not in adata.obsm):
                return opts, value
            
            item2d = dict(label='2D', value='2D')
            item3d = dict(label='3D', value='3D')
            
            dims = adata.obsm[basis].shape[1]
            opts = [item2d]
            if dims >= 3: 
                opts += [item3d]
            return opts, value#
    
        @self._app.callback(
            Output('embedding_plot', 'figure'),
            Input('basis_dropdown', 'value'),
            Input('layer_dropdown', 'value'),
            Input('color_by_radios', 'value'),
            Input('color_var_dropdown', 'value'),
            Input('gene_dropdown', 'value'),
            Input('plot_dims_radios', 'value'),
            Input('x_axis_dropdown', 'value'),
            Input('y_axis_dropdown', 'value'),
            Input('z_axis_dropdown', 'value'),
        )
        def update_plot(basis, layer, color_by, color_var, gene, plot_type, x_axis, y_axis, z_axis):
            '''
            Invokes `_make_plot` with the provided input and stores resultant figure in `._fig`
            Notes
            -----
            - Light input handling for layer ('X' --> None)
            '''
            if layer == 'X': layer = None
            fig = self._make_plot(adata, basis, layer, color_by, color_var, gene, plot_type, x_axis, y_axis, z_axis)
            self._fig = fig
            return fig
            
    def run(self, debug: bool = False, **kwargs):
        '''Run the Dash app'''
        self._app.run_server(debug=debug, **kwargs)
