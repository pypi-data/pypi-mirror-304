class CrossOriginInterface{static instances={};constructor(t){if(CrossOriginInterface.instances[t])return console.error("CrossOriginInterface instance already exists with key",t),CrossOriginInterface.instances[t];CrossOriginInterface.instances[t]=this,this.sortedAnchors=[],this.trackedAnchors=new Set,this.anchorVisibleStates={},this.activeAnchorId=null,this.component=null,this.autoUpdateAnchor=!1,this.key=t,this.styles=null,window.addEventListener("message",this.handleMessage.bind(this))}register(t,e,s){this.component=t,this.autoUpdateAnchor=e,this.emphasisStyle=s}updateStyles(t){this.styles=t}scroll(t){const e=document.getElementById(t);e&&e.scrollIntoView({behavior:"smooth",block:"start"}),this.emphasize(t)}emphasize(t){const e=document.getElementById(t);if(e){if(null===this.styles)return void console.error("Styles have not been set");const t=this.styles.anchorEmphasis||null;if(null===t)return void console.error("emphasisStyle has not been set");for(const s in t)e.style[s]=t[s];setTimeout((()=>{e.style.transform="scale(1)"}),600)}}updateActiveAnchor(t){this.trackedAnchors.has(t)?this.activeAnchorId=t:console.error("Anchor is not being tracked",t??"null")}checkBestAnchor(){if(this.activeAnchorId){if(this.anchorVisibleStates[this.activeAnchorId])return;let t=null;const e=this.sortedAnchors.indexOf(this.activeAnchorId);for(let s=e+1;s<this.sortedAnchors.length;s++){const e=this.sortedAnchors[s];if(this.anchorVisibleStates[e]){t=e;break}}if(null===t)for(let s=e-1;s>=0;s--){const e=this.sortedAnchors[s];if(this.anchorVisibleStates[e]){t=e;break}}null!==t&&(this.activeAnchorId=t,this.postMessage("updateActiveAnchor",this.activeAnchorId),this.activeAnchorId)}}postMessage(t,e){null!==this.component?this.component.postMessage({COMPONENT_method:t,key:this.key,anchor_id:e},"*"):console.error("Component has not been registered")}observer=new IntersectionObserver((t=>{t.forEach((t=>{const e=t.target.id;t.isIntersecting?this.anchorVisibleStates[e]=!0:(this.anchorVisibleStates[e]=!1,this.activeAnchorId===e&&this.checkBestAnchor())}))}),{threshold:[0,1]});trackAnchors(t){for(const e of t){if(this.trackedAnchors.has(e))return;const t=document.getElementById(e);if(!t)return void console.error("Anchor does not exist",e);this.trackedAnchors.add(e);let s=!1;for(let r=0;r<this.sortedAnchors.length;r++){const o=document.getElementById(this.sortedAnchors[r]);if(t.compareDocumentPosition(o)&Node.DOCUMENT_POSITION_FOLLOWING){this.sortedAnchors.splice(r,0,e),s=!0;break}}s||this.sortedAnchors.push(e),this.sortedAnchors.push(e),this.observer.observe(t)}}handleMessage(t){const{COI_method:e,key:s}=t.data;if(e&&s&&s===this.key){if(t.data,null===this.component)if("register"===e){const{auto_update_anchor:e,emphasis_style:s}=t.data;this.register(t.source,e,s)}else console.error("Must register component with this CrossOriginInterface before calling other methods");switch(e){case"register":break;case"updateStyles":const{styles:s}=t.data;this.updateStyles(s);break;case"scroll":const{anchor_id:r}=t.data;this.scroll(r);break;case"trackAnchors":const{anchor_ids:o}=t.data;this.trackAnchors(o);break;case"updateActiveAnchor":const{anchor_id:n}=t.data;this.updateActiveAnchor(n);break;default:console.error("Unknown method",e)}}}}function instantiateCrossOriginInterface(t){return new CrossOriginInterface(t)}