class CrossOriginInterface{static instances={};constructor(t){if(CrossOriginInterface.instances[t])return console.error("CrossOriginInterface instance already exists with key",t),CrossOriginInterface.instances[t];CrossOriginInterface.instances[t]=this,this.sortedAnchors=[],this.trackedAnchors=new Set,this.anchorVisibleStates={},this.activeAnchorId=null,this.component=null,this.autoUpdateAnchor=!1,this.key=t,this.styles=null,this.disable_scroll=!1,window.addEventListener("message",this.handleMessage.bind(this))}register(t,s,e){this.component=t,this.autoUpdateAnchor=s,this.emphasisStyle=e,this.key}updateConfig(t,s){this.styles=t,this.disable_scroll=s}scroll(t){const s=document.getElementById(t);if(s){const t=this.disable_scroll?"instant":"smooth";s.scrollIntoView({behavior:t,block:"start"})}this.emphasize(t)}emphasize(t){const s=document.getElementById(t);if(s){if(null===this.styles)return void console.error("Styles have not been set");const t=this.styles.anchorEmphasis||null;if(null===t)return void console.error("emphasisStyle has not been set");for(const e in t)s.style[e]=t[e];setTimeout((()=>{s.style.transform="scale(1)"}),600)}}updateActiveAnchor(t){this.trackedAnchors.has(t)?this.activeAnchorId=t:console.error("Anchor is not being tracked",t??"null")}checkBestAnchor(){if(this.activeAnchorId){if(this.anchorVisibleStates[this.activeAnchorId])return;let t=null;const s=this.sortedAnchors.indexOf(this.activeAnchorId);for(let e=s+1;e<this.sortedAnchors.length;e++){const s=this.sortedAnchors[e];if(this.anchorVisibleStates[s]){t=s;break}}if(null===t)for(let e=s-1;e>=0;e--){const s=this.sortedAnchors[e];if(this.anchorVisibleStates[s]){t=s;break}}null!==t&&(this.activeAnchorId=t,this.postMessage("updateActiveAnchor",this.activeAnchorId),this.activeAnchorId)}}postMessage(t,s){null!==this.component?this.component.postMessage({COMPONENT_method:t,key:this.key,anchor_id:s},"*"):console.error("Component has not been registered")}observer=new IntersectionObserver((t=>{t.forEach((t=>{const s=t.target.id;t.isIntersecting?this.anchorVisibleStates[s]=!0:(this.anchorVisibleStates[s]=!1,this.activeAnchorId===s&&setTimeout((()=>{this.checkBestAnchor()}),0))}))}),{threshold:[0,1]});trackAnchors(t){for(const s of t){if(this.trackedAnchors.has(s))return;const t=document.getElementById(s);if(!t)return void console.error("Anchor does not exist",s);this.trackedAnchors.add(s);let e=!1;for(let o=0;o<this.sortedAnchors.length;o++){const n=document.getElementById(this.sortedAnchors[o]);if(t.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_FOLLOWING){this.sortedAnchors.splice(o,0,s),e=!0;break}}e||this.sortedAnchors.push(s),this.sortedAnchors.push(s),this.observer.observe(t)}}handleMessage(t){const{COI_method:s,key:e}=t.data;if(s&&e&&e===this.key){if(t.data,null===this.component)if("register"===s){const{auto_update_anchor:s,emphasis_style:e}=t.data;this.register(t.source,s,e)}else console.error("Must register component with this CrossOriginInterface before calling other methods",t.data);switch(s){case"register":break;case"updateConfig":const{styles:e,disable_scroll:o}=t.data;this.updateConfig(e,o);break;case"scroll":const{anchor_id:n}=t.data;this.scroll(n);break;case"trackAnchors":const{anchor_ids:r}=t.data;this.trackAnchors(r);break;case"updateActiveAnchor":const{anchor_id:i}=t.data;this.updateActiveAnchor(i);break;default:console.error("Unknown method",s)}}}}function instantiateCrossOriginInterface(t){return new CrossOriginInterface(t)}